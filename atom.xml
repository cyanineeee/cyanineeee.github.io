<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cyanineeee.github.io</id>
    <title>cyanine</title>
    <updated>2024-09-30T09:08:21.961Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cyanineeee.github.io"/>
    <link rel="self" href="https://cyanineeee.github.io/atom.xml"/>
    <subtitle>my personal blog</subtitle>
    <logo>https://cyanineeee.github.io/images/avatar.png</logo>
    <icon>https://cyanineeee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, cyanine</rights>
    <entry>
        <title type="html"><![CDATA[git pr 进行 merge时的冲突解决]]></title>
        <id>https://cyanineeee.github.io/post/git-pr-jin-xing-merge-shi-de-chong-tu-jie-jue/</id>
        <link href="https://cyanineeee.github.io/post/git-pr-jin-xing-merge-shi-de-chong-tu-jie-jue/">
        </link>
        <updated>2024-09-30T02:10:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>首先是自己提交的pr和主分支出现了冲突 合并被reject</li>
<li>然后先拉取主分支 确认本地有两个：**<em>当前分支</em> **和 <em><strong>主分支</strong></em></li>
<li>然后将拉取到本地的主分支和自己的分支在本地merge（是<em><strong>本地</strong></em> 上  <em><strong>将远程分支合并到自己的分支</strong></em>）</li>
<li>逐文件、逐行确认冲突，是保留自己的？保留主分支？或是一起修改？</li>
<li>确认完成之后，即远端和自己的分支在<em><strong>本地</strong></em>合并完毕</li>
<li>然后将解决冲突完成的自己的分支提交到<em><strong>远程仓库的自己的分支</strong></em></li>
<li>在负责人确认无误后 同意本次pr即完成冲突解决</li>
</ul>
<pre><code> #可能用到的命令
 #查看分支
 git branch
 #切换分支
 git checkout 
 #查看分支更新日志(有分支的编码) 用来比对冲突的分支的版本、对比当前分支是否是最新的
 git log
 #将branchname合并到当前分支
 git merge&lt;branchname&gt;
 # 切换到分支branchname
 git checkout  &lt;branchname&gt;
 # 查看仓库状态 冲突的文件会是红色的
 git  status
 #查看具体冲突
 git diff &quot;冲突的文件&quot;
 # 将远程指定分支 拉取到 本地指定分支上
 git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;
 #取消尚未完成冲出处理的merge - 回滚到合并前的状态
 git merge --abort

</code></pre>
<ul>
<li>合并冲突方式
<ul>
<li>在vsc中，可以通过多屏协调进行选取（左右分别为本地、主分支，底部为合并后的）</li>
<li>在命令行中，需要结合编辑器进行修改</li>
</ul>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
修改后的代码（当前分支的修改）
=======
修改后的代码（冲突分支的修改）
&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch_name
</code></pre>
解决冲突步骤
<ul>
<li>
<ol>
<li>打开冲突文件，找到冲突部分</li>
</ol>
</li>
<li>
<ol start="2">
<li>根据实际需要修改、保留、删除</li>
</ol>
</li>
<li>
<ol start="3">
<li>保存</li>
</ol>
</li>
<li>通过 `git add &quot;修改后的冲突文件&quot;标记问已解决冲突的状态</li>
<li>全部解决完成之后<code>git commit</code>和  <code>git push</code>进行提交</li>
</ul>
</li>
</ul>
<h3 id="补充-git讲解stage">补充 -- <a href="https://blog.csdn.net/qq_32452623/article/details/78417609">git讲解stage</a></h3>
<h3 id="补充-git取消合并的更多讲解">补充 -- <a href="https://geek-docs.com/git/git-questions/94_git_source_tree_git_how_to_cancel_a_merge.html">git取消合并的更多讲解</a></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[antd Table多级表头时固定表头bug ]]></title>
        <id>https://cyanineeee.github.io/post/antd-table-duo-ji-biao-tou-gu-ding-biao-tou-wei-zheng-li/</id>
        <link href="https://cyanineeee.github.io/post/antd-table-duo-ji-biao-tou-gu-ding-biao-tou-wei-zheng-li/">
        </link>
        <updated>2024-09-27T08:07:35.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import React from 'react';
import { Table } from 'antd';
import type { TableColumnsType } from 'antd';
import { createStyles } from 'antd-style';

const useStyle = createStyles(({ css, token }) =&gt; {
  const { antCls } = token;
  return {
    customTable: css`
      ${antCls}-table {
        ${antCls}-table-container {
          ${antCls}-table-body,
          ${antCls}-table-content {
            scrollbar-width: thin;
            scrollbar-color: unset;
          }
        }
      }
    `,
  };
});

interface DataType {
  key: React.Key;
  name: string;
  age: number;
  street: string;
  building: string;
  number: number;
  companyAddress: string;
  companyName: string;
  gender: string;
}

const columns: TableColumnsType&lt;DataType&gt; = [
  {
    title: 'Name',
    dataIndex: 'name',
    key: 'name',
    width: 100,
    fixed: 'left',
    filters: [
      {
        text: 'Joe',
        value: 'Joe',
      },
      {
        text: 'John',
        value: 'John',
      },
    ],
    onFilter: (value, record) =&gt; record.name.indexOf(value as string) === 0,
  },
  {
    title: 'Other',
    children: [
      {
        title: 'Age',
        dataIndex: 'age',
        key: 'age',
        width: 150,
        sorter: (a, b) =&gt; a.age - b.age,
      },
      {
        title: 'Address',
        children: [
          {
            title: 'Street',
            dataIndex: 'street',
            key: 'street',
            width: 150,
          },
          {
            title: 'Block',
            children: [
              {
                title: 'Building',
                dataIndex: 'building',
                key: 'building',
                width: 100,
              },
              {
                title: 'Door No.',
                dataIndex: 'number',
                key: 'number',
                width: 100,
              },
            ],
          },
        ],
      },
    ],
  },
  {
    title: 'Company',
    children: [
      {
        title: 'Company Address',
        dataIndex: 'companyAddress',
        key: 'companyAddress',
        width: 200,
      },
      {
        title: 'Company Name',
        dataIndex: 'companyName',
        key: 'companyName',
      },
    ],
  },
  {
    title: 'Gender',
    dataIndex: 'gender',
    key: 'gender',
    width: 80,
    fixed: 'right',
  },
];

const dataSource = Array.from({ length: 100 }).map&lt;DataType&gt;((_, i) =&gt; ({
  key: i,
  name: 'John Brown',
  age: i + 1,
  street: 'Lake Park',
  building: 'C',
  number: 2035,
  companyAddress: 'Lake Street 42',
  companyName: 'SoftLake Co',
  gender: 'M',
}));

const App: React.FC = () =&gt; {
  const { styles } = useStyle();
  return (
    &lt;Table&lt;DataType&gt;
      className={styles.customTable}
      columns={columns}
      dataSource={dataSource}
      bordered
      size=&quot;middle&quot;
      scroll={{ x: 'calc(700px + 50%)', y: 47 * 5 }}
    /&gt;
  );
};

export default App;
</code></pre>
<p>以上代码 虽然<code>Company Address</code>是固定的，但是<code>Company</code>表头不是固定的，我们期望的情况是类似于这样：</p>
<pre><code>import React from 'react';
import { Table } from 'antd';
import type { TableColumnsType } from 'antd';
import { createStyles } from 'antd-style';

const useStyle = createStyles(({ css, token }) =&gt; {
  const { antCls } = token;
  return {
    customTable: css`
      ${antCls}-table {
        ${antCls}-table-container {
          ${antCls}-table-body,
          ${antCls}-table-content {
            scrollbar-width: thin;
            scrollbar-color: unset;
          }
        }
      }
    `,
  };
});

interface DataType {
  key: React.Key;
  name: string;
  age: number;
  street: string;
  building: string;
  number: number;
  companyAddress: string;
  companyName: string;
  gender: string;
}

const columns: TableColumnsType&lt;DataType&gt; = [
  {
    title: 'Other',
    children: [
          {
            title: 'Street',
            dataIndex: 'street',
            key: 'street',
            width: 150,
fixed:&quot;left&quot;,
          },
          {
                title: 'Building',
                dataIndex: 'building',
                key: 'building',
                width: 100,
           },
    ],
  },
  {
    title: 'Company',
    children: [
      {
        title: 'Company Address',
        dataIndex: 'companyAddress',
        key: 'companyAddress',
        width: 200,

      },
      {
        title: 'Company Name',
        dataIndex: 'companyName',
        key: 'companyName',
      },
    ],
  },
];

const dataSource = Array.from({ length: 100 }).map&lt;DataType&gt;((_, i) =&gt; ({
  key: i,
  name: 'John Brown',
  age: i + 1,
  street: 'Lake Park',
  building: 'C',
  number: 2035,
  companyAddress: 'Lake Street 42',
  companyName: 'SoftLake Co',
  gender: 'M',
}));

const App: React.FC = () =&gt; {
  const { styles } = useStyle();
  return (
    &lt;Table&lt;DataType&gt;
      className={styles.customTable}
      columns={columns}
      dataSource={dataSource}
      bordered
      size=&quot;middle&quot;
      scroll={{ x: 'calc(700px + 50%)', y: 47 * 5 }}
    /&gt;
  );
};

export default App;
</code></pre>
<p>这样Other和Street表头就会固定 -- 也就是最左侧的两个固定（如果只在中间列添加<code>fixed:&quot;left&quot;</code>是不起作用的），但是需求又需要最左侧父列和他的全部子列以及第二个父列和他的第一个子列固定，我的方案是通过css改变定位方式来解决。</p>
<pre><code>.user_table .ant-table-wrapper .ant-table-column-sorter {
  position: absolute;
  top: 18px;
  right: 10px;
}
&lt;!-- 同时该元素的背景设置为白色 --&gt;
</code></pre>
<p>这样就可以达到固定第二层妒父级表头的效果了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uwsgi - django部署]]></title>
        <id>https://cyanineeee.github.io/post/uwsgi-django-bu-shu/</id>
        <link href="https://cyanineeee.github.io/post/uwsgi-django-bu-shu/">
        </link>
        <updated>2023-07-04T11:18:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="以一个最基础的初始django-项目为例不涉及数据库">以一个最基础的初始django 项目为例（不涉及数据库）</h2>
<ol>
<li>将django项目的环境打包成requirements.txt</li>
<li>购买一个服务器</li>
<li>将服务器安全组设置 设置入站规则全开</li>
<li>配置python环境
<ul>
<li>本人使用的是ubuntu 20.04 自带python 3.8</li>
<li>首先安装pip - 注：如果<code>E: Package 'python3.10-venv' has no installation candidate</code>说明你应该更新一下系统的可安装软件列表<code>apt-get update</code></li>
<li>然后安装virtualenv</li>
<li>然后cd到想要的目录下 创建虚拟环境</li>
<li>cd到刚创建的虚拟环境目录下的bin文件夹内 source activate启动环境</li>
</ul>
</li>
<li>配置项目环境
<ul>
<li>cd到项目根目录 执行pip install -r requirements.txt （一定要在上一步启动虚拟环境之后在进行环境配置）</li>
<li>运行结束即可</li>
</ul>
</li>
<li>安装uwsgi
<ul>
<li>pip install uwsgi即可</li>
</ul>
</li>
<li>配置uwsgi.ini文件 - 在项目根目录中的同名目录下（就是个默认wsgi.py文件同一个文件夹下）</li>
</ol>
<pre><code class="language-ini">[uwsgi]
http=0.0.0.0:8000 #设置为0.0.0.0表示外网可以访问 127.0.0.1表示本机访问
chdir=/my/mysite  #项目根目录
wsgi-file=mysite/wsgi.py   #项目根目录里面的同名文件内的wsgi.py文件
process=2 #启动进程数 跟服务器cpu有关
threads=2 #线程数 
pidfile=uwsgi.pid  #储存进程的pid 以便于后面停止运行
daemonize=uwsgi.log #日志文件
master=true  #主进程启动
</code></pre>
<ol start="8">
<li>然后cd进入到uwsgi.ini同级内
<ul>
<li>执行uwsgi --ini uwsgi.ini 启动</li>
<li>此时就能通过公网ip+端口访问到djano服务了</li>
</ul>
</li>
<li>停止服务
<ul>
<li>uwsgi --stop uwsgi.pid进入到uwsgi.ini同级文件夹运行即可<br>
PS. 使用命令 ps aux|grep 'uwsgi'可以查看服务是否启动，出现如下表示正常：</li>
</ul>
</li>
</ol>
<pre><code>root       84204  1.0  3.8  47520 36724 ?        S    11:07   0:00 uwsgi --ini uwsgi.ini
root       84206  0.0  3.0 121252 29816 ?        Sl   11:07   0:00 uwsgi --ini uwsgi.ini
root       84207  0.0  2.7  47520 26280 ?        S    11:07   0:00 uwsgi --ini uwsgi.ini
root       84250  0.0  0.0   6432   720 pts/0    S+   11:08   0:00 grep --color=auto uwsgi
</code></pre>
<h3 id="10-彻底关闭uwsgi进程">10. 彻底关闭uwsgi进程</h3>
<p>如果没有设置停止的pid或者启动失败导致pid生成失败，这样就会导致有uwgsi进程挂在后台，因此需要彻底关闭：<code>pkill -f uwsgi -9</code></p>
<p>PS.</p>
<ul>
<li>如果uwsgi日志报错：<code>uwsgi invalid request block size: 4937 (max 4096)...skip</code><br>
代表请求过大（超过默认4k）因此跳过<br>
因此只要将请求接收的值方法即可：在uwsgi.ini文件添加<code>buffer-size = 65536</code> 即可。</li>
<li>这样部署之后，网站是请求不到静态文件的（css,js,图片等）所以需要再搭配nginx进行静态文件请求的处理。</li>
</ul>
<h2 id="uwsgi常见报错">uwsgi常见报错</h2>
<ul>
<li>
<p>1.启动失败： 端口被占用<br>
解决方法： 更换端口/停止占用端口的进程<br>
<code>sudo lsof -i:端口号</code> - 查看端口  <code>kill -9 端口号</code> - 停止端口进程</p>
</li>
<li>
<p>2.停止失败 stop无法关闭uwsgi<br>
原因： 重复启动uwsgi导致uwsgi.pid中进程号失效<br>
解决方法 ： ps 出uwsgi进程，手动kill</p>
</li>
<li>
<ol start="3">
<li>启动失败 找不到配置文件<br>
大概率uwsgi.ini中的chdir和wsgi两个参数的地址配置错误<br>
解决方法：修复即可，注意chdir是项目绝对路径，wsgi是<code>wsgi.py</code>文件的相对于项目根目录的路径</li>
</ol>
</li>
<li>
<p>安装uwsgi报错<code>ERROR: Failed building wheel for uwsgi</code><br>
搜索解决方法：更新pip即可 -  更新系统依赖 - 安装psycopg2-binary -<br>
都没有用<br>
最后：<code>apt-get install build-essential python3-dev</code>然后pip即可<br>
<a href="https://stackoverflow.com/questions/44037637/error-installing-uwsgi-in-virtualenv">stackoverflow</a></p>
</li>
<li>
<ol start="4">
<li>修改项目后再使用uwsgi启动报错</li>
</ol>
</li>
</ul>
<pre><code class="language-python">    raise ImproperlyConfigured(
django.core.exceptions.ImproperlyConfigured: The app module &lt;module 'cyanine' (namespace)&gt; has multiple filesystem locations (['/my/imsys/./cyanine', '/my/imsys/cyanine']); you must configure this app with an AppConfig subclass with a 'path' class attribute.
</code></pre>
<p>原因：没有正确设置app，因为想要添加一个展示页面作为项目的index，所以就直接将这个html文件以及附带的静态文件一股脑地放在一个文件夹里面然后添加到项目中，还在setting中注册了app名字，但是实际上这个app里面缺少对应的配置文件，这就开发模式下能够凭借文件路径运行正确，但生产模式部署的时候就导致uwgis运行的时候找不到文件路径报错。<br>
因此，对于django的app来说，需要有两个文件：<code>__init.py__</code>和<code>apps.py</code>文件，其中<code>apps.py</code>中内容为</p>
<pre><code class="language-python">from django.apps import AppConfig
class PollsConfig(AppConfig):
    default_auto_field = &quot;django.db.models.BigAutoField&quot;
    name = &quot;你注册在setting中的app名字&quot;
</code></pre>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx -- 学习 -- + uwsgi部署django项目]]></title>
        <id>https://cyanineeee.github.io/post/nginx-xue-xi/</id>
        <link href="https://cyanineeee.github.io/post/nginx-xue-xi/">
        </link>
        <updated>2023-07-04T09:36:46.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV1F5411J7vK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c66937bc5207a56bafe7811cb2b0c4da">教程-8.04开始</a></li>
</ul>
<h3 id="1-什么是nginx">1. 什么是nginx</h3>
<ul>
<li>轻量级的高性能3web服务器，提供了http代理和反向代理、负载均衡，使用c语言编写，效率极高。</li>
<li>一般使用uwsgi协议让nginx转发接收到的http协议给uWSGI（uwsgi协议是二进制，效率更高）</li>
</ul>
<h3 id="2-安装nginx">2. 安装nginx</h3>
<p><code>sudo apt install nginx</code><br>
安装成功之后输入<code>nginx -v</code>查看版本。<br>
PS. nginx安装之后会默认占用80端口</p>
<h3 id="3-配置nginx">3. 配置nginx</h3>
<p><code>/etc/nginx/site-enabled/default</code>是nginx的配置文件<br>
核心参数</p>
<ul>
<li>location / 有点像路由 表示所有这个路由的请求都由下面的参数代表的服务处理</li>
<li>uwsgi_pass 将服务以uwsgi传递给***地址（例如127.0.0.1:8000）</li>
<li>include 配置参数 如果需要使用uwsgi协议需要写 <code>/etc/nginx/uwsgi_params</code></li>
</ul>
<h3 id="4-启动停止nginx">4. 启动/停止nginx</h3>
<p><code>sudo /etc/init.d/nginx start|stop|restart|status</code> 分别代表启动|停止|重启|查看状态<br>
PS. nginx只要修改就需要重启，否则配置不生效</p>
<h3 id="5-修改uwsgi配置文件适配nginx修改nginx适配uwsgi启动">5. 修改uwsgi配置文件，适配nginx，修改nginx，适配uwsgi启动</h3>
<p>具体如下：</p>
<pre><code class="language-vim">#default文件
                # try_files $uri $uri/ =404; #注释掉这一句
                uwsgi_pass 127.0.0.1:8000;  #添加这两句
                include /etc/nginx/uwsgi_params;
</code></pre>
<pre><code>#uwsgi.ini
#去掉http 修改为 socket
socket = 127.0.0.1:8000 #这个端口号要和nginx的一致

</code></pre>
<p>PS. <code>sudo nginx -t</code>可以快速方便的告诉你配置文件是否有语法错误</p>
<h3 id="6-排错">6. 排错</h3>
<ul>
<li>看日志文件！ 访问日志：<code>/var/log/nginx/error.log</code> 错误日志：<code>/var/log/nginx/access.log</code>  对应uwsgi日志 - 和<code>uwsgi.ini</code>同级下的<code>uwsgi.log</code></li>
<li>502 代表nginx反向代理成功，但是对应的uwsgi未启动；还有一种就是uwsgi设置接受请求过小，在uwsgi.ini中添加<code>buffer-size = 65536</code>  -  主要还是得看日志</li>
<li>404（分两种：django报错/nginx报错）  一可能是路由不在django项目；二可能是没有禁止掉nginx配置文件里的<code>try_files</code></li>
</ul>
<h3 id="7-nginx静态文件配置">7. nginx静态文件配置</h3>
<ul>
<li>创建新文件夹 - 存放所有的django静态文件 -- 例如<code>/home/mysite_static/</code></li>
<li>在django setting.py中添加配置 <code>STATIC_ROOT</code>代表静态文件路径  -- 例如<code>/home/mysite_static/static/</code></li>
<li>进入django项目，执行<code>python3 mange.py collectstatic</code> - 收集项目所有的静态文件</li>
<li>nginx配置文件新增加</li>
</ul>
<pre><code class="language-vim">location /static {
root /静态文件夹;  
}
</code></pre>
<p>特别要注意路径，这个‘静态文件夹’下面还有一个static的文件夹，里面才是真正存放了所有的静态文件</p>
<h3 id="8-404500-自定义报错页面">8. 404/500 自定义报错页面</h3>
<ul>
<li>在django的模板文件夹内添加<code>404.html</code>文件，当视图触发http404的时候自动显示该页面（在debug=false的时候彩起作用） -- 添加完之后记得重启nginx、uwsgi等服务</li>
</ul>
<h3 id="9-给原来的静态文件夹下新增文件夹结果404">9. 给原来的静态文件夹下新增文件夹，结果404</h3>
<p>大概是因为项目中的静态文件路径和nginx的有所区别，<br>
需要注意alias和root的区别，<br>
nginx会根据请求的路径，去请求静态文件夹中可能存在的，文件夹中的静态文件。简而言之，nginx是可以嵌套的，但是前提是请求的路径需要对应的上。</p>
<h3 id="10-alias与root的区别">10. alias与root的区别</h3>
<p><a href="https://blog.csdn.net/m0_58709145/article/details/127754115">csdn参考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django学习 -- 前后端不分离的 -- part.3 ]]></title>
        <id>https://cyanineeee.github.io/post/django-xue-xi-qian-hou-duan-bu-fen-chi-de-part3/</id>
        <link href="https://cyanineeee.github.io/post/django-xue-xi-qian-hou-duan-bu-fen-chi-de-part3/">
        </link>
        <updated>2023-07-01T13:54:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="50ajax请求">50.ajax请求</h3>
<ul>
<li>get请求</li>
</ul>
<pre><code class="language-js">$.ajax({
    url : '你的url'，
    type : 'get',
    data:{
        ...
        //你的数据 json(k-v对)
    },
    dataType:'JSON', //将请求道的json数据转化为js对象
    success:function(res){ //res是返回值
        //你的操作...
    }
})
</code></pre>
<ul>
<li>post请求</li>
</ul>
<pre><code class="language-js">$.ajax({
    url : '你的url'，
    type : 'post',
    data:{
        ...
        //你的数据 json(k-v对)
    },
    dataType:'JSON', //将请求道的json数据转化为js对象
    success:function(res){ //res是返回值
        //你的操作...
    }
})
</code></pre>
<p>免除scrf的认证(这样ajax就可以不用携带csrf)</p>
<pre><code class="language-python">from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def exanple(request):
    #你的视图函数
</code></pre>
<p>PS. 需要记得，ajax请求的url在django中也需要注册在<code>urls.py</code>文件中。<br>
还有，ajax请求后端返回的必须是json格式（就是使用python的json模块对字典进行处理（dumps）一下）；或者django中有<code>JsonResponse</code>可以字典打包为json，不用自己处理。<br>
如果jq直接选中表单（通过id），通过<code>serialize()</code>方法就可以获取表单的所有数据（例如<code>$('#form').serialize()</code>），之后ajax发送到后台的就是一整个表单数据(后端通过<code>request.POST</code>获取的是一个字典)。</p>
<h3 id="51校验ajax提交的请求">51.校验ajax提交的请求</h3>
<ul>
<li>通过modelform<br>
<a href="https://www.bilibili.com/video/BV1NL41157ph?p=58&amp;vd_source=c66937bc5207a56bafe7811cb2b0c4da">4-12 1:00:50</a><br>
因为ajax提交表单数据后，后台获取的是一个字典，因此可以通过modelform的data实例化，然后使用<code>is_valid()</code>进行校验。</li>
</ul>
<h3 id="52formerrors中到底是什么">52.form.errors中到底是什么</h3>
<p>是一个django中的ErrorDict，它包含一个<code>as_json()</code>方法，可以自动帮助我们将它转化为json信息</p>
<h3 id="53jq中的each可以遍历给定的对象">53.jq中的<code>$.each()</code>可以遍历给定的对象</h3>
<pre><code class="language-js">$.each(对象,function(key,val ) =&gt; {
//...进行操作，k,v是假设他是一个字典对象，如果是列表或者其他的可迭代对象，那么就给函数传入的参数做相应的变化即可
}).
</code></pre>
<h3 id="54jq的next方法">54.jq的<code>.next()</code>方法</h3>
<p>选择给定元素紧邻的下一个元素<br>
<a href="https://www.w3school.com.cn/jquery/traversing_next.asp">解释link</a></p>
<h3 id="55记不清了可以回顾">55.记不清了可以回顾</h3>
<ul>
<li><a href="https://www.bilibili.com/video/BV1NL41157ph?p=58&amp;vd_source=c66937bc5207a56bafe7811cb2b0c4da">武沛齐-django3教程  5-1 </a></li>
</ul>
<h4 id="56jq的empty方法">56.jq的empty()方法</h4>
<ul>
<li>清除所选元素内的所有文本内容和子元素<br>
<a href="https://api.jquery.com/empty/">reference_empty()</a></li>
</ul>
<h3 id="57modelform后端自定义储存">57.modelform后端自定义储存</h3>
<p>如果我们设定了一个表单，但是用户不能修改编号等随机生成的信息，那么就需要在获取到post表单信息之后，手动添加。<br>
对于一个实例化之后的modelform类，通过<code>modelformexample.instance.自定属性=</code>来添加用户输入没有包含的字段。</p>
<h3 id="58modelform校验空字段">58.modelform校验空字段</h3>
<ul>
<li>如果在字段设置的时候添加<code>required = False</code>，那么表单字段可以为空，默认的True代表表单字段必须不能为空，否则会在校验之后添加“该字段不能为空”的错误提示信息。但是这个仅仅只是让表单不验空，后面的<code>clean_[字段]</code>还是会默认执行的（如果没有这个钩子函数就相当于不进行校验）。</li>
<li><a href="https://blog.csdn.net/Hackeryuan/article/details/108195456">reference</a><br>
PS. 当然，如果你在定义modelform或者form的时候不添加对应的字段，那么就不会校验这个字段，然后通过<code>.instance.自定属性=</code>来自定义储存字段，应用例如订单的完成事件、订单的编号等。</li>
<li>form和modelform的校验会发生在三种情况下：调用<code>is_valid()</code> ，调用<code>.errors</code>获取错误信息的时候还有直接调用<code>full_clean()</code>方法的时候。</li>
</ul>
<blockquote>
<p>These are normally executed when you call the is_valid() method on a form. There are other things that can also trigger cleaning and validation (accessing the errors attribute or calling full_clean() directly), but normally they won’t be needed.<br>
<a href="https://docs.djangoproject.com/zh-hans/4.2/ref/forms/validation/">reference_django_official</a></p>
</blockquote>
<h3 id="59-登录系统的用户录入到form表单中不需要用户填写">59. 登录系统的用户录入到form表单中，不需要用户填写</h3>
<p>通过session<br>
<code>request.session['info'][之前储存的字段属性]</code></p>
<h3 id="60-jq清空表单输入">60. jq清空表单输入</h3>
<ul>
<li>通过jq选取表单元素之后，获取dom元素，然后使用dom的<code>reset()</code>方法置空表单。<br>
<code>$('#表单id/选取表单')[0].reset();</code>  jq对象 -&gt; dom对象 -&gt; 使用reset()方法</li>
</ul>
<h3 id="61jq选择一组class可以直接绑定一组元素的事件">61.jq选择一组class可以直接绑定一组元素的事件</h3>
<pre><code class="language-js">$('.delete-btn').click(function() {
    $('#delete-modal').modal('show');
})
</code></pre>
<h3 id="62ajax删除确认需要设置全局变量">62.ajax删除确认需要设置全局变量</h3>
<p>因为删除到确认中间分步骤，需要通过全局变量来保证最终删除的可以获取到选择到的那一个元素。</p>
<h3 id="63-ajax的get请求传递方式">63. ajax的get请求传递方式</h3>
<ul>
<li>一种是直接拼接</li>
</ul>
<pre><code class="language-js">$.ajax({
    url :'login/order/delete/'+nid+'/',  //用于后台是通过
     type : 'GET',
     ..
})
</code></pre>
<p>用于django后端是通过get请求直接处理参数的视图函数，例如：</p>
<pre><code>#urls.py
    path('login/order/delete/&lt;int:id&gt;',views.order_delete,name ='order_delete'), #删除订单

#views.py视图函数
def order_delete(request,id):
    Orderform.objects.filter(id = id).delete()
    return redirect('/login/order/')
</code></pre>
<ul>
<li>另一种使通过data参数，让ajax帮助拼接url：</li>
</ul>
<pre><code class="language-js">$.ajax({
        url :'login/order/delete/', 
        type : 'GET',
        data:{
            id:nid,
        },
       ...    // =&gt; 最终的url ： login/order/delete/?id=&quot;nid的值&quot;
})
</code></pre>
<p>这样django就可以通过get获得url中的参数</p>
<pre><code class="language-python">def order_delete(request):
    id = request.GET.get('id')  #需要和传回的key相同
    Orderform.objects.filter(id = id).delete()
    return redirect('/login/order/')
</code></pre>
<h3 id="63对于forms或者modelform来说获取cleaned_data">63.对于forms或者modelform来说获取cleaned_data</h3>
<p>实际上两者从前端的request中获取方式是通过input框的name属性，之所以直接通过获取定义好的字段，是因为在模板中渲染的时候生成的input框自带一个和字段一样的name属性。所以如果打算不使用模板生成前端表单，那么获取表单的post请求的关键字，就是通过其中的input的name属性（是键值对类型的），这个也包括验证表单中的cleaned_data。</p>
<h3 id="64-django项目部署">64. django项目部署</h3>
<p>https://www.zhihu.com/question/348410145</p>
<p>https://pythondjango.cn/django/advanced/16-docker-deployment/</p>
<p>第二个</p>
<h1 id="看到5-6-暂且把项目做完部署">看到5-6 暂且把项目做完部署！</h1>
<p>项目做完啦~ 2023/07/05~ 继续补充一捏捏</p>
<h3 id="65-过滤敏感信息">65. 过滤敏感信息</h3>
<p><a href="https://www.bilibili.com/video/BV1vK4y1o7jH?p=48">b站 - 8.06 32:00</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django学习 -- 前后端不分离的 -- part.2]]></title>
        <id>https://cyanineeee.github.io/post/django-xue-xi-qian-hou-duan-bu-fen-chi-de-part2/</id>
        <link href="https://cyanineeee.github.io/post/django-xue-xi-qian-hou-duan-bu-fen-chi-de-part2/">
        </link>
        <updated>2023-06-30T12:36:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="35时间选择插件">35.时间选择插件</h3>
<p><a href="https://www.bootcss.com/p/bootstrap-datetimepicker/index.htm">download_link</a><br>
<a href="https://bootstrap-datepicker.readthedocs.io/en/latest/options.html">office_link</a><br>
<a href="https://blog.csdn.net/qq_28633249/article/details/77142352">usage</a></p>
<ul>
<li>使用极其简单：只需要选择dom然后绑定即可，在使用方法里可以设置各种参数</li>
</ul>
<pre><code class="language-js">$('#id_presettime').datetimepicker({
   format: 'yyyy-mm-dd hh:ii'
});   
</code></pre>
<h3 id="36modelfield定义成成表单的属性样式">36.modelfield定义成成表单的属性样式</h3>
<pre><code class="language-python">class orderForm(ModelForm):
    class Meta():
        model = Orderform
        fields = &quot;__all__&quot;

    #方法一 原生的属性
    widgets = {
        #为html表单中name类型的input标签添加&quot;class=form-control&quot;
        'name' : forms.TextInput(attrs = {&quot;class&quot; : &quot;form-control&quot;})
        #为html表单中password类型的input标签添加&quot;class=form-control&quot;
        'password' : formsPasswordInput( attrs = {&quot;class&quot; : &quot;form-control&quot;})
        ...
    }

    #方法二 扩写父类函数的属性
        def __init__(self,*arg,**kwargs):
            super().__init__(*arg,**kwargs)
            for name, field in self.fields.items():
                # print(name,field) #这个是展示 self.fields.items()可以直接拿到定义在Meta中的fields字段
                field.widget.attrs = {'class' : 'form-control'} #为生成的表单input赋予css属性 
</code></pre>
<ul>
<li>扩充 这个属性可以继承 不过暂时对我没什么用处 因此pass过</li>
</ul>
<h3 id="37修改dajngo的modelform类的input的type类型为datetime-local">37.修改dajngo的modelform类的<code>input</code>的<code>type</code>类型为<code>datetime-local</code></h3>
<ul>
<li>第一种是通过前端js实现，一共三步：第一拿到原始的时间数据，第二选择input框然后修改type，第三讲原始的时间数据修改格式之后在赋予给input框：</li>
</ul>
<pre><code class="language-js">function changeDatetimeInput(id){
    var time = $(`#${id}`).val().replaceAll('/','-');
    $(`#${id}`).attr('type','datetime-local');
    $(`#${id}`).val(time)
}
changeDatetimeInput('id_presettime');
changeDatetimeInput('id_endtime');
</code></pre>
<p>需要注意的是，后端django传来的之间类型是<code>yyyy/mm/dd hh:ii</code>，但是html内置的时间选择input框的时间字符串格式要求是<code>yyyy-mm-ddThh:ii</code>，因此需要将原来的斜杠（/）替换成短横（-），中间·的<code>T</code>是一个时间字符表示，可以用大写字符T表示，但最终解析的时候空格也可以，<a href="https://blog.csdn.net/jim_LoveQ/article/details/107457771">具体参考</a></p>
<ul>
<li>第二种就是修改django的<code>DateTimeInput</code><br>
这种看不懂原因，但是如果只是仅仅修改input_type的话是解析不了的，回答给出的原因是后端会因为输入合法判断和不通过，<a href="https://stackoverflow.com/questions/50214773/type-datetime-local-in-django-form">detail_link_and_solution</a></li>
</ul>
<pre><code class="language-python">from django import forms
class DateTimeLocalInput(forms.DateTimeInput):
    input_type = &quot;datetime-local&quot;

class DateTimeLocalField(forms.DateTimeField):
    # Set DATETIME_INPUT_FORMATS here because, if USE_L10N 
    # is True, the locale-dictated format will be applied 
    # instead of settings.DATETIME_INPUT_FORMATS.
    # See also: 
    # https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats
    input_formats = [
        &quot;%Y-%m-%dT%H:%M:%S&quot;, 
        &quot;%Y-%m-%dT%H:%M:%S.%f&quot;, 
        &quot;%Y-%m-%dT%H:%M&quot;
    ]
    widget = DateTimeLocalInput(format=&quot;%Y-%m-%dT%H:%M&quot;)
</code></pre>
<p>然后再自己的modelform中将想要修改input的typ类型为datetime-local的字段设置为<code>DateTimeLocalField</code>即可：</p>
<pre><code class="language-python">#用法
class orderEditForm(ModelForm):
    presettime = DateTimeLocalField() #在这里将想要的字段设置即可
    class Meta():
        model = Orderform
        fields = &quot;__all__&quot;
</code></pre>
<pre><code class="language-html">&lt;!-- {{field}}生成的具体样式  --&gt;
&lt;input type=&quot;text&quot; name=&quot;endtime&quot; value=&quot;1899/12/31 00:00&quot; class=&quot;form-control&quot; id=&quot;id_endtime&quot;&gt;
</code></pre>
<h3 id="38通过validationerror来为钩子方法设置非法输入提示信息">38.通过validationError来为钩子方法设置非法输入提示信息</h3>
<p><code>raise ValidationError</code></p>
<h3 id="39密码加密-通过钩子方法定义">39.密码加密 通过钩子方法定义</h3>
<ul>
<li>钩子方法返回的就是储存到数据库中</li>
<li>md5加密 加密需要“盐”，为了方便和效果 使用django在设置中生成的secret_key来当作“盐”</li>
</ul>
<pre><code class="language-python">from django.conf import settings
import hashlib

def md5(data_string):
    obj = hashlib.md5(settings.SECRET_KEY.encode('utf-8'))
    obj.update(data_string.encode('utf-8'))
    return obj.hexdigest()
</code></pre>
<h3 id="40对于djanfo的orm如果搜索不到">40.对于djanfo的ORM，如果搜索不到</h3>
<p>搜索不到就返回None，可以用来判断是否是合法请求</p>
<h3 id="41对于表单验证">41.对于表单验证</h3>
<p>所有验证通过的信息都储存在对应的<code>cleaned_data</code>中</p>
<h3 id="42django报错">42.django报错</h3>
<p><code>'Manager' object is not callable</code><br>
原因是<code>objects</code>是一个属性而不是一个方法，写成<code>objects()</code>会报这个错</p>
<h3 id="43用户登录">43.用户登录</h3>
<ul>
<li>cookies 和 session<br>
无状态短链接<br>
通过cookies给用户发放一个“凭证”， 保存在浏览器中的键值对，发送请求的时候自动携带<br>
session django默认储存在mysql中</li>
</ul>
<p>业务过程：收到用户的提交 -&gt; 校验（在数据库比较） -&gt; 成功 生成随机字符串写入到用户浏览器的cookies以及数据库中（这里只需要调用<code>request.session()</code>方法即可 django会自动处理两个事件），并且会将传入的字符经过处理之后，以<code>{session_key:session_data}</code>键值对的形式保存在数据库中，其中session_key就是传递给浏览器的cookies，而session_data就是在下面代码中定义的字典（经过字符转换，需要使用的时候django会解码）</p>
<pre><code class="language-python">        else: #登陆成功
            request.session['info'] = { #写入session
                'id':login_object.id,
                'name' : login_object.name,
            }
</code></pre>
<ul>
<li>
<p style="color:red;font-size:large;">PS. 特别需要注意的是，在后面的调用request.session中的属性的名字都是来自于此！</p>
</li>
</ul>
<p>因此需要在用户访问的时候判断用户是否登录 -&gt; 已登录继续访问 未登录跳转回登陆页面：<br>
用户请求-&gt; 拿到用户cookies并判断：</p>
<pre><code class="language-python">#第一种方法 在每个请求前都加上对于cookies的判断
    if not request.session.get('info'):
        return redirect('/login/')
</code></pre>
<p>太low😎<br>
应该使用django的中间件高效的处理</p>
<h3 id="44django中间件">44.django中间件</h3>
<p><a href="https://docs.djangoproject.com/zh-hans/4.1/topics/http/middleware/">官方文档</a></p>
<ul>
<li>对于django，每一个请求都需要经过很多中间件之后才能访问到视图函数；同样的，所有的视图函数返回值都需要经过很多中间件的处理才会返回给用户。</li>
<li>django的中间件都是类，通过<code>process_request</code>方法对传入的请求进行处理，通过<code>process_response</code>对视图函数的return进行包装。如果某个请求不能通过一个中间件，那么就会直接返回给用户，而不会到达视图函数。</li>
<li>中间件写好之后需要在setting.py文件中的MIDDLEWARE中注册（具体到类名），哪个在前面那个先执行。</li>
<li>中间的<code>process_request</code>方法如果返回为None，那么继续向后执行；如果需要返回，那么返回的类型与视图函数的返回类似（例如render,redirect,HttpResponse等），并且不在向后执行。</li>
<li>应用中间件：
<ul>
<li>1.注册中间件</li>
<li>2.中间件中返回值</li>
<li>3.通过中间件实现登录校验<br>
代码实现</li>
</ul>
</li>
</ul>
<pre><code class="language-python">#middleware.py文件
from django.utils.deprecation import MiddlewareMixin
from django.shortcuts import render,redirect
from django.http import HttpResponse

class SessionChectMiddleware(MiddlewareMixin):
    def process_request(self,request):
        #排除不需要登陆的页面
        allow_url = ['/login/','/register/']
        if request.path_info in allow_url:
            return
        #读取session
        info = request.session.get('info')
        if info:
            return
        else: 
            return redirect('/login/')
</code></pre>
<pre><code class="language-python">#在setting.py文件中注册
MIDDLEWARE = [
    &quot;django.middleware.security.SecurityMiddleware&quot;,
...... ,
    &quot;cake.middleware.SessionChectMiddleware&quot;,
]
</code></pre>
<p>PS. request.path_info可以获取到请求的url路径。</p>
<h3 id="45注销操作-用户退出登录">45.注销操作 - 用户退出登录</h3>
<p>也就是将浏览器的cookies和session删除<br>
同样使用request.session中的方法即可</p>
<h3 id="46通过session获取用户登录信息显示在导航栏">46.通过session获取用户登录信息显示在导航栏</h3>
<p>每次视图函数的中传递的request中都包含session参数，因此可以直接在模板中调用<code>{{request.session.info.属性}}</code>来获取对应的信息（因为request是默认传递的），不用刻意通过别的模板参数来渲染。</p>
<pre><code class="language-python">    &lt;button class=&quot;btn btn-secondary dropdown-toggle btn-sm&quot; type=&quot;button&quot; id=&quot;dropdownMenuButton2&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt;
                        {{ request.session.info.name}}
&lt;/button&gt;
</code></pre>
<h3 id="47form和modelform">47.form和modelform</h3>
<ul>
<li>form可以自定义字段<br>
modeform既可以自定义 还可以在数据库中拿取字段</li>
<li>form没有save方法可以直接存入到数据库 但是modelform有</li>
</ul>
<h3 id="48图片验证码">48.图片验证码</h3>
<p>-&gt; python中如何动态生成图片并写入值 (不做过多了解 仅仅当成黑盒使用)<br>
<a href="https://www.cnblogs.com/crischou/p/7152974.html">参考文献</a></p>
<ul>
<li>需要pillow库</li>
</ul>
<pre><code class="language-python">import random
from PIL import Image,ImageFont,ImageDraw,ImageFilter
#需要注意！！ 这里的字体文件font_file路径组合是基于运行的根目录决定的 需要根据相对位置的不同进行调整！这里我将他放在根目录下面的static/文件夹内
def check_code(width=120, height=30, char_length=5, font_file='./static/kumo.ttf', font_size=28):
    # font = ImageFont.load_default() #使用默认字体
    code = []
    img = Image.new(mode='RGB', size=(width, height), color=(255, 255, 255))
    draw = ImageDraw.Draw(img, mode='RGB')
    def rndChar():
        &quot;&quot;&quot;
        生成随机字母   
        :return:
        &quot;&quot;&quot;
        return chr(random.randint(65, 90))
    def rndColor():
        &quot;&quot;&quot;
        生成随机颜色
        :return:
        &quot;&quot;&quot;
        return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255))
    # 写文字
    font = ImageFont.truetype(font_file, font_size)
    for i in range(char_length):
        char = rndChar()
        code.append(char)
        h = random.randint(0, 4)
        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())
    # 写干扰点
    for i in range(40):
        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())
    # 写干扰圆圈
    for i in range(40):
        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())
        x = random.randint(0, width)
        y = random.randint(0, height)
        draw.arc((x, y, x + 4, y + 4), 0, 90, fill=rndColor())
    # 画干扰线
    for i in range(5):
        x1 = random.randint(0, width)
        y1 = random.randint(0, height)
        x2 = random.randint(0, width)
        y2 = random.randint(0, height)

        draw.line((x1, y1, x2, y2), fill=rndColor())

    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)
    return img,''.join(code)
 
if __name__ == '__main__':
    # 1. 直接打开
    # img,code = check_code()
    # img.show()
 
    # 2. 写入文件
    img,code = check_code()
    with open('code.png','wb') as f:
        img.save(f,format='png')
 
    # 3. 写入内存(Python3)
    # from io import BytesIO
    # stream = BytesIO()
    # img.save(stream, 'png')
    # stream.getvalue()
 
    # 4. 写入内存（Python2）
    # import StringIO
    # stream = StringIO.StringIO()
    # img.save(stream, 'png')
    # stream.getvalue()

    pass
</code></pre>
<p style='color:red'>需要注意！！`check_code()`的字体文件`font_file`路径组合是基于运行的根目录决定的 需要根据相对位置的不同进行调整！这里我将他放在根目录下面的`static/`文件夹内</p>
+ 然后就是部署到djang中：主要是将前端请求图片的url替换为动态的，然后生成验证码的视图函数返回对应的验证码图片。
```python
from .function.checkcode import check_code #这个就是刚才的生成验证码图片的函数
from io import BytesIO #将图片储存到内存中需要用的库
<p>def image_code(request):<br>
'''生成验证码'''<br>
img,str = check_code()<br>
print(str)<br>
stream = BytesIO()<br>
img.save(stream, 'png')</p>
<pre><code>return HttpResponse(stream.getvalue()) #从内存中读取到图片然后以http response的形式传回给前端 前端的img标签解析之后就是一个图片
</code></pre>
<pre><code>```html
&lt;img src=&quot;/image/code/&quot;&gt; 
&lt;!-- 只要调用对应的url就可以 --&gt;

</code></pre>
<p>PS. 需要注意的是：同一个文件中不要出现名字相同的函数，不管是引用的还是本文件的，会导致调用出错</p>
<h3 id="49如何验证验证码呢">49.如何验证验证码呢？</h3>
<p>通过session！ - 这样每个用户在登陆的时候对于验证码的验证就不会受到干扰，并且重复刷新也会更新session中对应的验证码。<br>
这里有很多需要注意的点！</p>
<ul>
<li><code>add_errors()</code>可以向forms中指定字段添加错误提示信息，然后能在前端的<code>{{fields.属性字段.errors.0}}</code>中取到。</li>
<li>由于验证码的字段是没有在用户model/数据库表中存在的，因此如果直接传入<code>request.POST</code>作为data参数会报错。因此应该将验证码字段单独剔除。</li>
<li>验证码验证需要调用之前创建验证码时存入session的字段，将两个字段相比较判断是否正确。</li>
<li>登录成功之后需要重新设置session的过期时间 ，因为为了验证码的登录时效，在生成验证码的时候会设置保存验证码对比字段的session信息时效比较短，因此登录成功之后需要重新设置。<br>
最终的登录逻辑</li>
</ul>
<pre><code class="language-python">from .models import UserInfo #model中的类 是最原本的用户信息类 包括账户名和密码以及自动生成的id
from io import BytesIO #生成图片储存在内存
from .encrypt import md5 #加密

class loginForm(forms.Form):
    name = forms.CharField(label='用户名',widget=forms.TextInput(
        attrs = {
            'class' :&quot;my-input-item&quot;
        }
    ))
    password = forms.CharField(label='密码',widget=forms.PasswordInput(
        attrs = {
            'class' :&quot;my-input-item&quot;
        }
    ))
    code = forms.CharField(label='验证码',widget=forms.TextInput(
        attrs={
            'class':&quot;my-input-item&quot; ,
            'style':&quot;margin-top:0;&quot; ,
            'placeholder':&quot;验证码&quot;
        }
    ),required=True)

    def cleaned_password(self):
        return md5(self.changed_data.get('password')) #md5加密

#登录页面 
def login(request):
    if request.method == 'GET':
        form = loginForm()
        return render(request,'login.html',{
            'form':form
        })

    login_form = loginForm(data=request.POST)
    if login_form.is_valid():
        user_input_code = login_form.cleaned_data.pop('code') 
        #验证码的校验
        code = request.session.get('image_code','') #这个是在生成验证码的时候存入session中的，如果过时或者获取不到默认为空
        if code.upper() != user_input_code.upper(): #不考虑大小写 
            #如果验证码不相等
            login_form.add_error('code','验证码错误')
            return render(request,'login.html',{
                'form' : login_form,
            })

        login_object = UserInfo.objects.filter(**login_form.cleaned_data).first() #校验用户密码
        if not login_object:
            login_form.add_error('name','用户名或密码错误')
            return render(request,'login.html',{
                'form' : login_form,
            })
        else: #登陆成功
            request.session['info'] = { #写入session
                'id':login_object.id,
                'name' : login_object.name,
            }
            request.session.set_expiry(60 * 60 * 24 * 7) #再重新设置session 保存7天
            return redirect('/login/manage/')
    else: #表单验证未通过
        return render(request,'login.html',{
                'form' : login_form,
            }) 

#生成验证码
def image_code(request):
    '''生成验证码'''
    img,str = check_code()
    request.session['image_code'] = str
    request.session.set_expiry(60) #设置验证码session 60s过时
    stream = BytesIO()
    img.save(stream, 'png')
    return HttpResponse(stream.getvalue())
</code></pre>
<p>PS. UserInfo是在model.py文件中的ORM类，对应着储存登录用户帐号密码的数据库表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql -- null和空的区别]]></title>
        <id>https://cyanineeee.github.io/post/mysql-null-he-kong-de-qu-bie/</id>
        <link href="https://cyanineeee.github.io/post/mysql-null-he-kong-de-qu-bie/">
        </link>
        <updated>2023-06-29T14:14:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>空值时不占用空间的； 2、null其实是占用空间的； 打个比方来说，你有一个杯子，空值代表杯子是真空的，NULL代表杯子中装满了空气，虽然杯子看起来都是空的，但是区别是很大的。 NULL 其实并不是空值，而是要占用空间，所以mysql在进行比较的时候，NULL 会参与字段比较，所以对效率有一部分影响</p>
</blockquote>
<ul>
<li><a href="https://blog.51cto.com/u_3303362/3795308">null和空的区别</a></li>
</ul>
<p>那什么时候用null什么时候用空值呢？</p>
<blockquote>
<p>更推荐使用空值。两者的含义不一样，前者代表不清楚，后者代表缺失值。但实际使用上null会在数据库操作方面造成很多的麻烦，因此更推荐设置为空值，并且字段设置为<code>NOT NULL</code></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django学习 -- 可以感受到最原始的django框架是前后端不分离的 -- part.1]]></title>
        <id>https://cyanineeee.github.io/post/lin-shi-ji-lu/</id>
        <link href="https://cyanineeee.github.io/post/lin-shi-ji-lu/">
        </link>
        <updated>2023-06-26T16:21:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h2 id="学习视频"><strong><a href="https://www.bilibili.com/video/BV1NL41157ph/?p=45&amp;spm_id_from=pageDriver&amp;vd_source=c66937bc5207a56bafe7811cb2b0c4da">学习视频</a></strong></h2>
</li>
</ul>
<h3 id="1请求和响应">1.请求和响应</h3>
<ul>
<li>get post redirect</li>
</ul>
<h3 id="2数据库操作">2.数据库操作</h3>
<ul>
<li>mysql+pymsql</li>
<li>ORM框架 -&gt; 帮助我们处理sql语句 =&gt; pip install mysqlclient<br>
创建修改删除数据中的表（不用写sql语句）<br>
操作表中的数据<br>
=&gt; 创建数据库 django连接数据<br>
PS. 需要在setting.py进行设置</li>
</ul>
<h3 id="3让django帮助创建数据库表">3.让django帮助创建数据库表</h3>
<ul>
<li>django会通过model中的类帮助生成sql创建表和字段<br>
类名代表表明 属性代表列名</li>
</ul>
<pre><code class="language-python">class UserInfo(models.Model):
    name = models.CharField(max_length=32)
    password = models.CharField(max_length=64)
</code></pre>
<h3 id="4执行命令">4.执行命令</h3>
<ul>
<li>需要提前注册app -&gt; 在setting.py中注册<br>
python manage.py makemigrations<br>
python manage.py migrate</li>
</ul>
<h3 id="5需要注意">5.需要注意</h3>
<ul>
<li>在已经有的model类中添加属性 可能会导致原来已经有的数据缺失新增加的列的数据<br>
django给出了两个选择，一是在命令行中默认添加输入，二是在新增加的属性字段中增加 <code>default=</code>字段，代表给原来没有的缺失值赋值。例如：<br>
<code>age = models.CharField(defalut=18)</code><br>
或者设置可以为空<br>
<code>age = models.CharField(null=True,blank=True)</code></li>
</ul>
<h3 id="6通过django向表中插入数据">6.通过django向表中插入数据</h3>
<ul>
<li>
<p><code>UserInfo.objects.create(name='cyanine',password=&quot;123456&quot;)</code> 插入数据 需要类中的属性对应<br>
<code>a = UserInfo.objects.all()</code>获取所有数据 以列表返回，其中每一个元素都是一个对象 通过<code>.属性</code>获取具体的数据<code>a.name</code>，结合<code>.filter()</code>可以进行筛选查询<br>
<code>.first()</code>获取获取到的第一个对象</p>
</li>
<li>
<p>删除数据<br>
<code>.delete()</code><br>
可以添加<code>filter</code>进行筛选 例如<code>UserInfo.objects.filter(name='cyanine').delete()</code> 删除所有name为cyanine的数据<br>
使用<code>.all()</code>选择全部<code>UserInfo.objects.all().delete()</code>删除这张表中的所有数据</p>
</li>
<li>
<p>更新数据<br>
<code>UserInfo.objects.all().updata(password=123456)</code>更新所有的password为123456<br>
还可以结合<code>.filter()</code>进行筛选</p>
</li>
</ul>
<h3 id="7django表单如果不写action-那么默认提交就是向当前页面发送一个post请求">7.django表单如果不写action 那么默认提交就是向当前页面发送一个post请求</h3>
<h3 id="8django中的url命名能避免对url的硬编码">8.django中的url命名能避免对url的硬编码，</h3>
<ul>
<li>例如修改一个url 的路径如果以前在html采用的是硬编码，直接写对应的会导致后面修改维护极为困难。<br>
但是如果采用url命名空间，那么修改的url并不会直接影响到，django会通过url的命名访问到，而不是硬编码。<code>{% url 'url_name' other_param%}</code>  这个url_name 就是在urls.py文件中的<code>path('url/example', views.function,name = url_name)</code>的name为url从的重命名，这样修改path对应的url，就不用在维护前端的页面了。</li>
</ul>
<h3 id="9model添加约束-数据库的约束">9.model添加约束 (数据库的约束)</h3>
<ul>
<li>例如员工表和部门表之间的关系，让员工表和部门表关联，通过<code>ForeignKry</code>方法中的<code>to</code>和<code>to_field</code>参数在django中设置。用途是可以方便对输入数据的合法性判断，例如员工不能属于一个不存在的部门，就可以很方便的进行判断。</li>
<li>在员工表中<br>
<code>department = models.ForeignKey(to = 'Department', to_field = 'id')</code><br>
这就将员工表和部门表进行了关联，员工的部门只能属于Depatment中的一个；<code>to</code>表示关联的表名，<code>to_field</code>表明关联的表的一个列名字段。要注意的是，django在储存这样的字段时默认命名方式是<code>关联表名_id</code>（例如这个就是<code>depaetment_id</code>）。<br>
于此对应，在获取的时候，如果直接通过字段/属性获取的话，例如<code>obj.联表名_id</code>，获取到的时储存在这张表中的对应关联表的数字，而不是我们想要的具体指代，因此django规定了如果直接<code>.联表名</code>就可以获取到关联表对应的那一行数据（封装为一个queryobj对象），然后就可以继续通过关联表内的属性进行查找。例如，部门表中一共有两个部门，字段为（id,部门名），内容为（1，主管部）（2，运行部），员工表关联</li>
<li>级联删除 置空null<br>
现在设想一种情况，如果部门表中的一个部门取消掉，那么与之关联的员工应该如何处理呢？常用的就是两种操作：将他们一并删除（这就是级联删除）；还有一种就是将他们设置为null。对应的这两种方式在django中需要这样设置：<br>
<code>department = models.ForeignKey(to = 'Department', to_field = 'id',on_delete=models.CASCADE)</code> 级联删除<br>
<code>department = models.ForeignKey(to = 'Department', to_field = 'id',null=True,blank=True,on_delete=models.SET_NULL)</code> 置空  需要注意的是 置空的前提就是这个字段可以为空<code>null = True</code> 这些都是django中的操作。</li>
</ul>
<h3 id="10性别存储">10.性别存储</h3>
<ul>
<li>model的choice 与数据库无关 是django的特性 可以方便的进行固定的选择储存。例如男女，单独为男女添加一个char字段会较为浪费空间，因此使用1/2这样的数字代替，但是数字不易读，因此django设计出了<code>choice</code>参数。</li>
</ul>
<pre><code class="language-python">gender_choice = (
    (1,'男'),
    (2,'女'),
) #注意是元组套元组
gender = models.SmallIntegerField(verbose_name='性别',choices = gender_choice) #verbose_name就是对列名（属性）的注解 可写可不写 写上为好
#SmallIntegerField是小整数字段
</code></pre>
<ul>
<li>这样字段的获取：如果直接<code>obj.gender</code>获取的就是数据库中对应的数字，但是django封装了一个判断方法，可以很方便的帮我们判断，然后返回的是我们希望现实的字段：<code>obj.get_gender_display()</code>。其中函数名字组成方式为<code>get_属性名字/字段名字_display()</code></li>
</ul>
<h3 id="11form和modelform">11.Form和ModelForm</h3>
<ul>
<li>11.1 form类 自动生成表单</li>
</ul>
<pre><code class="language-python">#views.py
class MyForm(Form):
    user = forms.CharField(widget=forms.Input)
    password = forms.CharField(widget=forms.Input)
    email = forms.CharField(widget=forms.Input)
def user_add(request):
    form = MyForm() #实力化一个form表单类
    return render（request,'user_add.html',{'form':form}
</code></pre>
<pre><code class="language-html">&lt;!-- user_add.html --&gt;
&lt;form method='post'&gt;
{% for i in form %}
{{ i }}
{% endfor %}
&lt;!-- 或者也可以一个一个自己写出来 比如{{form.user}} {{form.password}} --&gt;
&lt;/form&gt;
</code></pre>
<ul>
<li>11.2 ModelForm组件
<ul>
<li>实现数据库表单字段和前端form表单字段的自动生成</li>
</ul>
<ul>
<li>对连接表/外键限制自动生成选择框</li>
<li>定义models类中的<code>__str__</code>方法实现对连接表属性的直接展示</li>
<li>定义生成表单样式的属性</li>
<li><code>{{ obj.label }}</code>可以遍历出在modelform定义字段中的<code>label</code>参数<br>
接下来是具体的代码展示 有点太多了...<br>
记得添加了路由！！！（这个就不展示在代码中了，）</li>
</ul>
</li>
</ul>
<pre><code class="language-python">#views.py
#根据staff表单生成modelform类
class staffMdoelForm(ModelForm):
    class Meta:
        model = Staff
        fields = ['name','age','gender','phonenumber','create_time']

#添加员工
def staff_add(request):
    form = staffMdoelForm() #实例化modelform类 
    return render(request,'staff_add.html',{
        'form':form
        })
</code></pre>
<pre><code class="language-html">&lt;div style=&quot;width:50%;margin-left: 25%;margin-top: 25px;&quot;&gt;
    &lt;div class=&quot;container&quot; &gt;
        &lt;form method=&quot;post&quot;&gt;
            &lt;h2&gt;添加新的员工信息&lt;/h2&gt;
            {% csrf_token %}
            {% for field in form %}
            &lt;div class=&quot;mb-3&quot;&gt;
                &lt;label class=&quot;form-label&quot;&gt;{{field.label}}&lt;/label&gt;
                {{ field }}
            &lt;/div&gt;
            {% endfor %}
            &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;确认添加&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;    
&lt;/div&gt;
</code></pre>
<pre><code class="language-python">#连接表modelform处理（html不用做太多改变）
#在models.py中的从表添加__str__方法 让调用这个类的时候返回的不再是一个queryobject而是__str__定义好的返回值
class Staff(models.Model):
    name = models.CharField(verbose_name='员工姓名',max_length=32)
......
    def __str__(self):
        return self.name
#在views.py中定义modelform类的时候 字段选择直接写定义的而不是在数据库表单中的字段
class userModelForm(ModelForm):
    class Meta:
        model = UserInfo #注 Userinfo表单中的identify是引用了Staff表单中的id作为外键
        fields = ['name','password','identify']
</code></pre>
<h3 id="12重定向">12.重定向</h3>
<ul>
<li><code>from django.shortcuts import redirect</code>或者<code>from django.http import HttpResponseRedirect</code><br>
return一个重定向url的实例即可</li>
</ul>
<h3 id="13前端url实现删除请求">13.前端url实现删除请求</h3>
<ul>
<li>通过前端发送一个带有删除目标信息的GET请求，然后后端获取删除即可，但是这个带有删除目标信息的url该如何组装呢？通过url的组成规律，添加<code>/?id=</code>信息传递，代码如下：<br>
<code>&lt;a href=&quot;/login/manage/delete/?id={{user.0}}&quot;&gt;删除&lt;/a&gt;</code>  #这其中的{{id.0}}通过django的模板语法动态赋予目标的id信息<br>
对应处理函数（记得注册url）</li>
</ul>
<pre><code class="language-python">def delete_user_info(request):
    id = request.GET.get('id')
    UserInfo.objects.filter(id = id).delete()
    return HttpResponseRedirect('/login/manage/')
</code></pre>
<h3 id="14django的模板语法">14.django的模板语法</h3>
<ul>
<li>其中最开始的<code>{% extends 'nav.html'%}</code>必须处于子页面的第一个加载位置，意味着如果前面有哪怕<code>{% load static %}</code>也会报错。</li>
</ul>
<h3 id="15django正则匹配url">15.django正则匹配url</h3>
<ul>
<li>这样就不用前端写带有get参数的url，后端也不需要get获取,而是直接作为一个解析好的参数传递给视图进行处理，二是直接及进行请求和解析。同时也要注意，在url中添加的正则顺序不影响在命名url中的参数顺序</li>
</ul>
<ul>
<li>具体如下：</li>
</ul>
<pre><code class="language-python">#html中
&lt;a href=&quot;{% url 'edit' user.0 %}&quot;&gt;操作...&lt;/a&gt;
#url中
path('login/manage/&lt;int:id&gt;/edit/',views.edit_user_info,name = 'edit')
#views中
def edit_user_info(request,id):
    default_userinfo = UserInfo.objects.filter(id = id).first()
    ....
</code></pre>
<p>可以看到<code>&lt;int:id&gt;</code>是在<code>/edit/</code>之前的，但是在html的url中这个顺序不影响。同时在views中对应的函数可以直接接收到url中正则匹配到的参数，而不用再通过解析get请求获取。</p>
<h3 id="16在django的模板中可以通过objget_联表名_display获取到和后端get_联表名_display的效果直接返回对照过后的结果而不是对应的关联id">16.在django的模板中，可以通过<code>obj.get_联表名_display</code>获取到和后端<code>get_联表名_display()</code>的效果，直接返回对照过后的结果而不是对应的关联id。</h3>
<h3 id="17django的模板可以进行的额外操作">17.django的模板可以进行的额外操作：</h3>
<ul>
<li><code>{{number : add 1}}</code>就是python的<code>+=1</code>操作，<code>{{datetime | date :'Y-m-d}}</code>就是python中的<code>strftime()</code>函数(要注意的是里面的格式不需要带<code>%</code>)</li>
</ul>
<h3 id="18modelform的字段校验函数">18.modelform的字段校验函数</h3>
<ul>
<li><code>is_valid()</code>检验提交post请求中的form表单中的字段是否为空，具体的字段就是在<code>modelform</code>中<code>fields</code>列表定义的那些.</li>
<li>同时还可以在modelforms类中进行字段校验 错误的信息会保存在用post请求实例化的modelform中。</li>
</ul>
<pre><code class="language-python">class staffMdoelForm(ModelForm):
    phonenumber = forms.CharField(label='电话号码',max_length=11,min_length=11)#进行的字段校验 
    #规定电话号码的长度为11位
    #还可以通过validators参数进行正则筛选
    class Meta:
        model = Staff
        fields = ['name','age','gender','phonenumber','create_time']
    phonenumber = forms.CharField(label='电话号码',max_length=11,min_length=11)
    #规定电话号码的长度为11位
    #还可以通过validators参数进行正则筛选
</code></pre>
<h3 id="19调整返回的提示信息为汉语">19.调整返回的提示信息为汉语</h3>
<ul>
<li>通过修改setting.py文件中的语言项</li>
</ul>
<pre><code class="language-python">#setting.py
# LANGUAGE_CODE = &quot;en-us&quot; 注释掉
LANGUAGE_CODE = &quot;zh-hans&quot; #添加
</code></pre>
<h3 id="20modelform中instance参数">20.modelform中<code>instance</code>参数</h3>
<ul>
<li>通过设置单条数据对表单进行填充，例如：</li>
</ul>
<pre><code class="language-python">#views.py中的一个方法
default_userinfo = UserInfo.objects.filter(id = id).first() #根据id在数据库中获取对应的一条数据
userform = userModelForm(instance=default_userinfo) # 通过instance参数设定一个实例化的表单 让他在前端渲染的时候自动在value上显示从数据库中拿到的默认值
</code></pre>
<ul>
<li>通过<code>instance</code>参数和<code>data</code>参数可以实现数据库数据的更新</li>
</ul>
<pre><code class="language-python">#在views.py中的某个函数
default_userinfo = UserInfo.objects.filter(id = id).first()
userform = userModelForm(data=request.POST,instance=default_userinfo)
if userform.is_valid():
    userform.save()
    return redirect('/login/manage/')
else:
    return render(request,'edit_info.html',{
        'userform': userform,
    })
</code></pre>
<ul>
<li>如果想在用户输入以外的字段进行更新，那么在modelform实例化之后通过<code>instacne</code>属性可以修改：</li>
</ul>
<pre><code class="language-python">userform = userModelForm(data=request.POST,instance=default_userinfo)
# useform.instance.字段 =  值
</code></pre>
<h3 id="21django查询排序">21.django查询排序</h3>
<ul>
<li><code>obj.objects.all().order_by('属性名')</code><br>
如果给属性名前面添加减号 代表逆向（高到低）排序</li>
</ul>
<h3 id="22给原有的表中添加新的字段产生错误djangocoreexceptionsvalidationerror-error">22.给原有的表中添加新的字段产生错误<code>&quot;django.core.exceptions.ValidationError&quot; error</code></h3>
<ul>
<li>产生原因：大概率是因为追加新的字段设置默认值的时候产生的格式错误，例如datetime格式但是没有设置默认或者默认格式错误，造成这样的原因。</li>
<li>解决方法：重置所有的<code>migrations</code></li>
<li>操作：删除migrations文件夹下除了<code>__init__.py</code>文件以外所有的文件，然后重新执行数据库迁移命令：<code>python manage.py makemigrations</code>, <code>python manage.py migrate</code></li>
<li>如果还不成功可能是因为数据库中原本存在的数据导致，将数据库清库（所有表删除），然后在执行即可。</li>
</ul>
<h3 id="23django报错orderform-object-has-no-attribute-get">23.django报错<code>'orderForm' object has no attribute 'get'</code></h3>
<ul>
<li>原因是在设置<code>input</code>标签的样式的时候重写的父类方法出错，参数多写了一个<code>self</code></li>
</ul>
<pre><code class="language-python">#错误源码
    def __init__(self,*arg,**kwargs):
        super().__init__(self,*arg,**kwargs)
        for name, field in self.fields.items():
            # print(name,field) #这个是展示 self.fields.items()可以直接拿到定义在Meta中的fields字段
            field.widget.attrs = {'class' : 'form-control'} #为生成的表单input赋予css属性 
</code></pre>
<ul>
<li>解决方法 ： 去掉<code>super().__init__(self,*arg,**kwargs)</code>这一行中的self即可，正确写法：<br>
<code>  super().__init__(*arg,**kwargs)</code></li>
<li>探究一下为什么<code>super</code>不需要<code>self</code>作为方法的第一个参数：<br>
因为<code>super()</code>是一个类 <a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html#hidsuper">reference</a> -- 感觉好多...暂时搁置一下...😖</li>
</ul>
<h3 id="24关闭浏览器校验">24.关闭浏览器校验</h3>
<p>在form表单添加<code>novalidate</code></p>
<pre><code class="language-html">&lt;form method=&quot;post&quot; novalidate &gt;
</code></pre>
<h3 id="25关于models中null和black字段">25.关于models中null和black字段</h3>
<ul>
<li>需要同时开启，但是数据库更推荐默认值为空值，因此设置<code>default=None</code>而不是<code>null</code>。<br>
如果设置<code>blank=True</code>但是不开启<code>null=True</code>，那么在插入的时候，如果传回来的数据为空，插入会报错不能为null字段...总之还是很迷惑的报错....但是解决方法还是最好设置两个都为True并且设置默认字段为<code>None</code>。如果为<code>null</code>，那么在数据传入到前端的时候会默认输出null或者none，而不是将那片区域置空，对于前端的用户输入逻辑不太友好。</li>
</ul>
<h3 id="26modelforms便捷写法">26.modelforms便捷写法</h3>
<ul>
<li>在添加fields的时候，可以用<code>__all__</code>一次性获取全部，<code>exclude = [ 排除的字段 ]</code>排除掉不要的字段。</li>
</ul>
<pre><code class="language-python">class orderForm(ModelForm):
    class Meta():
        model = Orderform
        fields = &quot;__all__&quot; #注意要引号
        # exclude = ['字段1','字段二', .... ]
</code></pre>
<h3 id="27后端表单正则校验">27.后端表单正则校验</h3>
<ul>
<li>在modelforms类中声明字段，然后通过validators参数设置正则表达式：</li>
</ul>
<pre><code class="language-python">from django.core.validators import RegexValidator #需要导入正则类
class exampleModelForms(forms.ModelForm):
    moblie = forms.CharField(
        label = '手机号码',
        validactors = [RegexValidator(r'^1[3-9]\d{9}$','手机号格式错误')]       
        #校验失败返回后面的提示信息而不是默认的了~ 
    )
</code></pre>
<h3 id="28钩子方法进行字段校验">28.钩子方法进行字段校验</h3>
<ul>
<li><a href="https://www.cnblogs.com/open-yang/p/11223175.html">详细的</a></li>
<li>这里摘列出常用的代码结果</li>
</ul>
<pre><code class="language-python">class exampleModelForms(forms.ModelForm):
   def clean_字段名(self): #这个需要在一个modelform类中 这个函数名modelform会自动生成对应的方法
           pass 
           name = self.cleaned_data.get('name')
           if name=='admin':
               raise ValidationError('admin是超级管理员，不能注册！')#这个错误会直接扔进该字段的错误类别中：name.errors
           return self.cleaned_data.get('name')
</code></pre>
<h3 id="29规定modelform中不可编辑的部分">29.规定modelform中不可编辑的部分</h3>
<p>在modelform中字段中设置参数<code>disabled= True</code>即可，这样在前端页面渲染出来的这一条字段是不可以更改的。</p>
<h3 id="30通过modelform判断要添加的数据是否重复">30.通过modelform判断要添加的数据是否重复</h3>
<ul>
<li><code>order_edit_form = orderEditForm().filter(id=你要查询的).exist()</code> 返回True/False<br>
这个方法需要添加在modelform中的钩子方法中。</li>
<li>排除自己以外的是否存在重复？(主要是在修改数据的时候）<br>
通过<code>exclude</code>排除自己后判断：<code>order_edit_form = orderEditForm().exclude(id='自己的id' ).filter(id=你要查询的).exist()</code> 返回True/False</li>
</ul>
<p>总结 编辑和添加的不同</p>
<h3 id="31查询根据某个字的一部分进行">31.查询（根据某个字的一部分进行）</h3>
<ul>
<li><code>filter()</code>还支持传入字典：</li>
</ul>
<pre><code class="language-python">order_edit_form = orderEditForm().filter(id=你要查询的,other=你要查询的)
#等于
query_dict = { 'id' : 要查询的, 'other' : 要查询的 }
order_edit_form = orderEditForm().filter(**query_dict)
 #需要注意传入字典的时候需要两个**
</code></pre>
<p>PS. 通常我们再变量前加一个星号(*)表示这个变量是元组/列表，加两个星号表示这个参数是字典</p>
<h3 id="32问题记录modelform不能更新一行数据的部分字段">32.问题记录：modelform不能更新一行数据的部分字段</h3>
<ul>
<li><a href="https://www.qiniu.com/qfans/qnso-8216353#comments">解决方法</a><br>
这里的解决方法很多 包括自定义钩子函数对post数据进行清晰、定义一个工厂函数处理每次不同的字段等，不过都太高端了，部分概念我还没有理解清楚😭</li>
<li>因此我打算采取最简单的 -- 一个字段一个字段的去<code>update</code>😳。 或者采用dict的模式，处理不变的字段和更新后的字段 组合成为一个更新后的字典然后通过modelform保存..</li>
<li>最后发现是我实例化出错了的问题....(真诚的眼瞎😭)</li>
</ul>
<pre><code class="language-python">    row_object = Orderform.objects.filter(id = id).first() #注意这里实例化的是一个form类 之前错误的原因是这里也写成了一个modelform类 这就导致下面instance的时候会报错 而且默认不更新的前端数据实际上是会传递回来的 作为表单的默认值
    order_edit_form = orderEditForm(data=request.POST,instance=row_object) 
    #这里实例化的是一个modelforms类
</code></pre>
<h3 id="33django的条件查询">33.django的条件查询</h3>
<p>除了固定的等于（<code>=</code>）查询外，还可以通过给字段/属性添加下划线的方式规定范围查询</p>
<ul>
<li>数字方面：gt、gte、lt、lte：大于、大于等于、小于、小于等于。<br>
<code>list = BookInfo.objects.filter(id__gt=3) </code> 代表id大于3的数据<br>
PS. 不等于可以通过<code>exclude</code>过滤</li>
<li>字符串方面：startswith、endswith：以指定值开头或结尾；contains：是否包含。<br>
<code>list = BookInfo.objects.filter(btitle__endswith='部')</code> 查询是否数据中btitle字段以‘部’这个字结尾的一行数据。</li>
<li>日期查询： year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。<br>
<code>list = BookInfo.objects.filter(bpub_date__year=1980)</code> 查询1980年发表的图书<br>
<code>list = BookInfo.objects.filter(bpub_date__gt=date(1990,1,1))</code>  查询1980年1月1日后发表的图书。</li>
<li>还有很多查询： 例如比较同一行数据两个字段之间的关系（如阅读数量&gt;=评论数量）、与或非查询、聚合等... 具体参考<a href="https://www.jianshu.com/p/bde1ece240bc">reference</a>或者官网</li>
</ul>
<p>PS. 1. <code>filter</code>可以连续使用 ：<code>list=BookInfo.objects.filter(bread__gt=20).filter(id__lt=3)</code> 2. <code>filter</code>可以传入字典</p>
<h3 id="34设置get默认值">34.设置get默认值</h3>
<ul>
<li><code>request.GET.get('page', '1')</code> 获取get请求，如果get没有附带page参数，那么默认是1.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Extra details of python - for long term - part.2]]></title>
        <id>https://cyanineeee.github.io/post/extra-details-of-python-for-long-term-part2/</id>
        <link href="https://cyanineeee.github.io/post/extra-details-of-python-for-long-term-part2/">
        </link>
        <updated>2023-06-26T04:11:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2023-06-26">2023-06-26</h1>
<h3 id="9-python中的__init__py">9. python中的__init__.py</h3>
<p><a href="https://zhuanlan.zhihu.com/p/115350758">reference</a><br>
在python工程中，当python在一个目录下检测到<code>__init__.py</code>文件时，就会把它当成一个module。<code>__init__.py</code>可以是空的，也可以有内容。</p>
<p>--未整理完</p>
<h3 id="10-python中的getattr方法">10. python中的getattr()方法</h3>
<p><code>getattr</code>方法可以获取一个模块其中的方法和属性，包括class名、直接定义的方法以及属性。<br>
代码示例：</p>
<pre><code class="language-python">#在example.py文件中
class magical_method():
    def __init__(self,num1,num2,num3):
        self.num1 = num1
        self.num2 = num2
        self.num3 = num3
    def __contains__(self,tar):
        if tar == self.num1 or tar == self.num2 or tar == self.num3:
            return False
        else:
            return True
    def name(self):
        print('qwe')

def another_example():
    print('asdasd')

ppp = 2
</code></pre>
<pre><code class="language-python">#在同目录下的test.py文件中
import example
attr = dir(example)
print(attr)
</code></pre>
<pre><code class="language-python">#输出
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'another_example', 'magical_method', 'ppp']
</code></pre>
<p>需要注意的几个点：一只会输出直接定义在模块中的类名、方法、属性（变量），如果属性/方法/类是在其他类/方法之下，那么不会遍历出来；二可以通过<code>isinstance(attr, type)</code>方法判断是否是类、<code>callable(func_name)</code>判断是否是函数（是否可以被调用）、<code>hasattr(obj, attr)</code>用来判断属性是否在指定类中；三如果没有<code>__name__ == &quot;__main__&quot;</code>，那么在dir的时候会执行该模块。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python网络编程 -- 建立一个http服务器+twisted模块--part.2]]></title>
        <id>https://cyanineeee.github.io/post/part2/</id>
        <link href="https://cyanineeee.github.io/post/part2/">
        </link>
        <updated>2023-06-26T03:45:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="">=&gt;</h1>
<p>HTTP基础响应</p>
<ol>
<li>http服务器</li>
</ol>
<pre><code class="language-python"># 1.首先需要socket进行协议、端口设置
# 2. 然后因为性能原因 需要设置多进程响应处理客户端请求
# 3. 设置处理客户端发送信息
# 4. 返回响应的html以及http头信息
import socket
import multiprocessing
class HttpServer:
    def __init__(self,port):  #进行socket初始设置 绑定端口开启监听
        self.port = port
        self.server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #实例socket对象
        self.server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #进行socket选项设置
        self.server_socket.bind(('0.0.0.0',port)) #绑定监听端口
        self.server_socket.listen() #开启监听 在构造函数内开启监听代表每一个实例都是一个http服务器程序

    def start(self): #接收服务端信息 进行处理
        while True:
            client_scoket, client_addr = self.server_socket.accept()
            print(f'【新的客户端连接】客户端ip{client_addr[0]},访问端口{client_addr[1]}')
            handle_socket = multiprocessing.Process(target=self.handle_response,args=(client_scoket,))#启动一个进程处理这个客户端请求
            handle_socket.start()

    def handle_response(self,client_socket): #处理客户端发送的请求信息
        request_headers = client_socket.recv(1024)
        print(f'【客户端清请求头信息】{request_headers}') #处理客户端请求头信息

        #开始处理响应给客户端的信息
        response_start_line = 'HTTP/1.1 200 OK\r\n' #本次相应成功
        #手动写http响应头 之后会发送给客户端会被浏览器解析
        response_header = 'Server:Cyanine Hrrp Server\r\nContent-Type:text/html\r\n'
        #返回的html代码 也就是页面主题 最基本的开发就是需要在代码中硬嵌入html页面代码
        response_body = &quot;&lt;html&gt;&quot;\
                            &quot;&lt;head&gt;&quot;\
                                &quot;&lt;meta charset=utf-8&gt;&quot;\
                                &quot;&lt;title&gt;Cyanine Http Server Response&lt;/title&gt;&quot;\
                            &quot;&lt;/head&gt;&quot;\
                            &quot;&lt;body&gt;&quot;\
                                &quot;&lt;h1&gt;&quot;\
                                &quot;Cyanine's Http server response...&quot;\
                                &quot;&lt;/h1&gt;&quot;\
                            &quot;&lt;/body&gt;&quot;\
                        &quot;&lt;/html&gt;&quot;
        #要注意在响应头和响应body之间添加换行 否则浏览器不能解析出响应内容
        response = response_start_line + response_header + '\r\n'+response_body
        client_socket.send(bytes(response,'UTF-8')) #服务器响应
        client_socket.close() #https是无状态协议 因此相应完成一次之后就会关闭连接

def main():
    #80端口大部分服务的默认端口 因此如果使用的话 就可以直接属于域名/主机地址访问服务
    #如果不是的话 需要指定端口 :**
    http_server = HttpServer(9090)
    http_server.start()
if __name__ == '__main__':
    main()
</code></pre>
<p>一些代码更详细的讲解<br>
<code>self.server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #实例socket对象</code><br>
ocket(family,type[,protocol])函数中，family 指定应用程序使用的通信协议的协议族，对于TCP/IP协议族，该参数为AF_INET；type 是要创建套接字的类型，socket.SOCK_STREAM表示流式socket，使用TCP协议的时候选择此参数，SOCK_DGRAM数据报式socket，使用UDP协议的时候选择此参数；protocol 指明所要接收的协议类型，通常为0或者不填。<br>
<code>self.server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #进行socket选项设置  level: 设置选项所在的协议层编号，有四个可用配置项，其中socket.SOL_SOCKET表示基本嵌套字接口....剩下的好复杂，看不太懂，暂且放下。看到的[参考](https://blog.csdn.net/c_base_jin/article/details/94353956) </code>client_socket.send(bytes(response,'UTF-8')) #服务器响应<br>
使用<code>bytes</code>的原因是socket只能发送字节数据流，因此需要将response转换为bytes类型，再发送。</p>
<h1 id="-2">=&gt;</h1>
<p>http服务器建立相应目录<br>
之前的http服务只能进行一次固定的响应，并且html代码出现在python代码中不方便修改，没有进行前后端分离，较为落后。因此我们可以建立一个目录，目录下有不同的HTML页面，根据请求的不同，相应响应目录下对应的html文件。<br>
具体实现：</p>
<pre><code class="language-python"># 添加相应目录 原因在于代码维护以及更加高效的响应
# 需要注意 读取html或者其他文件都是以bytes的格式
# os的注意点 os.getcwd() os.sep os.path.normpath()
# 正则的写法 暂不做详细了解 

import socket
import os #os处理响应文件目录
import re #正则匹配请求中的文件地址
import multiprocessing
HTML_ROOT_DIR = os.getcwd() + os.sep + &quot;template&quot;

class HttpServer:
    def __init__(self,port):  #进行socket初始设置 绑定端口开启监听
        self.port = port
        self.server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #实例socket对象
        self.server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #进行socket选项设置
        self.server_socket.bind(('0.0.0.0',port)) #绑定监听端口
        self.server_socket.listen() #开启监听 在构造函数内开启监听代表每一个实例都是一个http服务器程序

    def start(self): #接收服务端信息 进行处理
        while True:
            client_scoket, client_addr = self.server_socket.accept()
            print(f'【新的客户端连接】客户端ip{client_addr[0]},访问端口{client_addr[1]}')
            handle_socket = multiprocessing.Process(target=self.handle_response,args=(client_scoket,))#启动一个进程处理这个客户端请求
            handle_socket.start()
    
    #读取对应文件数据
    def read_file(self,file_name):
        file_path = os.path.normpath(HTML_ROOT_DIR + file_name)
        print('【请求文件路径】'+ file_path)
        f = open(file_path,'rb') #二进制读取
        file_data = f.read()
        f.close()
        print('【请求文件路径】该文件请求结束！')
        return file_data

    #获取二进制文件
    def get_binary_data(self,file_name):
        response_body = self.read_file(file_name)
        return response_body

    #读取html文件 返回相应的信息
    def get_html_file(self,file_name):
        response_start_line = 'HTTP/1.1 200 OK\r\n' #本次相应成功
        #手动写http响应头 之后会发送给客户端会被浏览器解析
        response_header = 'Server:Cyanine Hrrp Server\r\nContent-Type:text/html\r\n'
        response_body = self.read_file(file_name)
        return response_start_line + response_header + '\r\n' + response_body.decode('utf-8')
    def handle_response(self,client_socket): #处理客户端发送的请求信息
        request_headers = client_socket.recv(1024)
        print(f'【客户端清请求头信息】{request_headers}') #处理客户端请求头信息
        file_name = re.match(r&quot;\w+ +(/[^ ]*)&quot;, request_headers.decode('utf-8').split('\r\n')[0]).group(1)
        if file_name == &quot;/&quot;: #如果请求的是根目录 那么实际访问的是index.html页面
            file_name = '/index.html'
        if file_name.endswith(&quot;.html&quot;) or file_name.endswith(&quot;.htm&quot;):
            client_socket.send(bytes(self.get_html_file(file_name),'utf-8'))
        else:
            response_start_line = 'HTTP/1.1 200 OK\r\n' #本次响应成功
            response_header ='Server:Cyanine Hrrp Server\r\nContent-Type:image/x-icon\r\n'
            client_socket.send((response_start_line + response_header + '\r\n').encode('utf-8'))
            client_socket.send(self.get_binary_data(file_name))
        client_socket.close() #https是无状态协议 因此相应完成一次之后就会关闭连接

def main():
    #80端口大部分服务的默认端口 因此如果使用的话 就可以直接属于域名/主机地址访问服务
    #如果不是的话 需要指定端口 :**
    http_server = HttpServer(70)
    http_server.start()
    
if __name__ == '__main__':
    main()
</code></pre>
<p>代码细节解析<br>
一这是一个简单的http服务器相应目录，只是简单处理index.html、hello.html以及favicon.ico文件；二为了结构清晰，尽管获取<code>get_binary_data()</code>方法只是给<code>read_file</code>换了个名字，但是能够将功能更加清晰的分割开来；三不管什么响应，都要记得添加对应的http响应头；四响应头和响应内容和分开发送；五要注意手写响应头的时候各个部分之间的<code>\r\n</code>；<br>
同时这里还遇到了一个难以理解的问题，如果是以80端口启动服务，那么就算favicon的请求没有响应头，浏览器也会正确解析出来并显示图标，但是如果换成其他的端口，那么就不能正常相应，必须要添加响应头。猜测可能是因为80端口是默认，而请求favicon也是默认的一个请求，因此在这个活动中，浏览器会自动解析把，但是非默认端口就不可以。<a href="https://blog.csdn.net/laocooon/article/details/130762587#comments_27306408">和一位相同问题的大佬的讨论以及他的代码</a>。这个问题怎么也找不到答案，因此暂且搁置吧😭。总是还是要记得在每一个响应前添加响应头。不过当然针对简单的，复杂的话有很多web框架会帮我们滴~~~</p>
<h1 id="-3">=&gt;</h1>
<p>动态请求处理<br>
web有两个处理阶段：静态处理阶段、动态处理阶段。<br>
之前的响应目录实际上是静态处理，而动态web是可以根据动态的判断决定最终返回的数据内容。<br>
python动态处理实现：(只是简单的原理了解，不涉及复杂的动态相应框架)</p>
<pre><code class="language-python"># 处理动态请求 
import socket
import os #os处理响应文件目录
import re #正则匹配请求中的文件地址
import multiprocessing
HTML_ROOT_DIR = os.getcwd() + os.sep + &quot;template&quot;
import sys 
sys.path.append('packages')

class HttpServer:
    def __init__(self,port):  #进行socket初始设置 绑定端口开启监听
        self.port = port
        self.server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #实例socket对象
        self.server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #进行socket选项设置
        self.server_socket.bind(('0.0.0.0',port)) #绑定监听端口
        self.server_socket.listen() #开启监听 在构造函数内开启监听代表每一个实例都是一个http服务器程序

    def start(self): #接收服务端信息 进行处理
        while True:
            client_scoket, client_addr = self.server_socket.accept()
            print(f'【新的客户端连接】客户端ip{client_addr[0]},访问端口{client_addr[1]}')
            handle_socket = multiprocessing.Process(target=self.handle_response,args=(client_scoket,))#启动一个进程处理这个客户端请求
            handle_socket.start()

    def handle_response(self,client_socket): #处理客户端发送的请求信息
        request_headers = client_socket.recv(1024)
        print(f'【客户端清请求头信息】{request_headers}') #处理客户端请求头信息
        file_name = re.match(r&quot;\w+ +(/[^ ]*)&quot;, request_headers.decode('utf-8').split('\r\n')[0]).group(1)
        if file_name.startswith('/packages'): #访问动态页面
            #获取动态参数 
            request_name = file_name[file_name.index('/',1)+1:]#访问路径
            # print(&quot;访问路径：&quot;+request_name)
            param_value = '' #请求参数
            if request_name.__contains__('?') :#？是url中的参数分隔符号
                request_value = request_name[request_name.index('?') + 1 :]
                param_value = request_value.split('=')[1]
                request_name = request_name[0:request_name.index('?')]
                # print(request_name)
            model_name = request_name.split('/')[0]
            method_name = request_name.split('/')[1]
            model = __import__(model_name)
            method = getattr(model,method_name)
            response_body = method(param_value)
            print('【响应数据是】：'+response_body)

            response_start_line = 'HTTP/1.1 200 OK\r\n' 
            #手动写http响应头 之后会发送给客户端会被浏览器解析
            response_header = 'Server:Cyanine Hrrp Server\r\nContent-Type:text/html\r\n'
            response = response_start_line+response_header+'\r\n'+response_body
            print(response)
            client_socket.send(bytes(response,'UTF-8'))
        client_socket.close()


def main():
    #80端口大部分服务的默认端口 因此如果使用的话 就可以直接属于域名/主机地址访问服务
    #如果不是的话 需要指定端口 :**
    http_server = HttpServer(80)
    http_server.start()
    
if __name__ == '__main__':
    #http://localhost/packages/echo/service?param=canshu
    main()
</code></pre>
<p>同时还需要一个在同目录下的packages文件夹，文件路径如下</p>
<pre><code>├─packages
│  │  echo.py
│  │  __init__.py
│  │  
│  └─__pycache__
│          echo.cpython-310.pyc
│          echo.cpython-311.pyc
│          
├─template
│      favicon.ico
│      hello.html
│      index.html
│        
├─网络编程
│      01-server.py
│      02-client.py
│      03-echo-server.py
│      04-echo-client.py
│      05-UDP-server.py
│      06-UDP-client.py
│      07-broadcast-client.py
│      08-broadcast-server.py
│      09-http-server.py
│      10-http-lib-server.py
│      11-dynamic-request.py #这个是本文件
</code></pre>
<p>其中的/packages/echo.py文件内容如下：</p>
<pre><code class="language-python">def service(text):
    if text:
        response = f'&lt;head&gt;&lt;title&gt;Cyanine\'s Http Server&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;参数信息：{text}&lt;/h1&gt;&lt;/body&gt;'
        return response
    else:
        return '&lt;h1&gt;没有参数信息&lt;/h1&gt;'
</code></pre>
<p>需要注意的：<br>
一在<code>packages</code>文件夹下一定要有<code>__init.py__</code>文件，这样才能在<code>__import__</code>的时候正确识别到模块，同时也需要提前设定默认的模块路径（<code>sys.path.append(path/to/module)</code>）；二响应的时候除了需要确定响应头，在响应的html代码中需要规定编码方式，否则会出现乱码（<code>&lt;meta charset=utf-8&gt;</code>)；三动态处理我刚听起来高大上，但实际上操作一遍，感受就是对url的解析，加上一些程序处理参数，就是动态处理；四动态处理url需要用到很多对字符串的操作。<br>
PS. 另外一个方便的小tips，在写项目结构的时候，命令行里使用<code>tree</code>会生成目录结构，<code>tree &gt; txtname.txt</code>会将目录输出到这个txt文件中，参数<code>/f</code>会显示所有的文件层级，不加参数只会显示到所有的目录层级。</p>
<h1 id="-4">=&gt;</h1>
<p>urllib3模块<br>
用这个模块可以实现浏览器的模拟访问，是urllib的升级版，两者功能类似，只有细微差别。</p>
<h1 id="-5">=&gt;</h1>
<p>Twisted模块 (类似java中nio)<br>
是python中专门实现异步处理的io概念，主要是提升服务端的数据处理能力。理解twisted的设计思想，那么需要对比传统的服务器程序开发。早期没有多核CPU概念，单线程处理的效率低下，多线程并发编程有可能产生死锁问题（不同进程以及线程之间的等待和唤醒机制）（因为都是一个一个进程去执行）。所以后来，如果不使用并发编程，就不会产生种种问题（资源切换、系统调度、同步与等待等），</p>
<blockquote>
<p>阻塞设计<br>
服务端与客户端的recv<br>
会浪费大量服务器资源 -&gt; 这就是阻塞IO</p>
</blockquote>
<p>多线程是不能解决阻塞IO的，因此最好的方法是非阻塞IO（分为同步非阻塞IO和异步非阻塞IO），因此实现下来就是在一个进程中不断地进行循环处理<br>
-&gt; twisted是一个事件驱动型的网络引擎，最大的特点就是提供有一个事件循环处理，当外部事件发生时，使用回调机制来触发相应的操作处理，多个任务在一个线程中执行的时候，这种方式可以使程序尽可能地减少对其它线程的以来，也使得程序开发人员不再关注线程安全问题。<br>
-&gt; twisted中的所有处理事件全部交给reactor进行统一管理。<br>
-&gt; reactor 进行所有输出输出有关的事件注册。在整个程序的运行中，reactor循环会以单线程的形式持续运行，当需要执行回调处理的时候会停止循环，当回调操作执行完毕之后将继续采用循环的形式进行其他任务处理。</p>
<h1 id="-6">=&gt;</h1>
<p>使用twisted开发TCP程序<br>
会使服务端的资源利用带来极大便利。</p>
<ol>
<li>服务端：</li>
</ol>
<pre><code class="language-python">import twisted
import twisted.internet.protocol
import twisted.internet.reactor

SERVER_PORT = 8080

class Server(twisted.internet.protocol.Protocol): #继承父类
    def connectionMade(self): #复写服务端连接方法
        print(f'客户端{self.transport.getPeer().host}连接成功...')
        return super().connectionMade() 
    def dataReceived(self, data: bytes): #复写服务端数据接收方法
        print('【服务端收到数据】' + data.decode('utf-8')) #处理操作
        self.transport.write(('【ECHO】' + data.decode('utf-8')).encode('UTF-8')) #进行回应 类比socket的send
        return super().dataReceived(data)

#注册reactor
#reactor根据工厂获得相应事件回调处理类
class DefaultServerFactory(twisted.internet.protocol.Factory):
    protocol = Server

def main():
    #服务监听
    twisted.internet.reactor.listenTCP(SERVER_PORT,DefaultServerFactory())
    print('服务器启动完毕，等待客户端连接...')
    twisted.internet.reactor.run()

if __name__ == '__main__':
    main()
</code></pre>
<ol start="2">
<li>客户端</li>
</ol>
<pre><code class="language-python">import twisted
import twisted.internet.protocol
import twisted.internet.reactor

SERVER_PORT = 8080
SERVER_HOST = 'localhost'

class Client(twisted.internet.protocol.Protocol):
    def connectionMade(self):
        print('服务器连接成功...')
        self.send() #建立连接之后就发送数据
        return super().connectionMade()
    
    def send(self): #自定义发送的方式
        input_data = input('请输入发送的数据:')
        if input_data:
            self.transport.write(input_data.encode('utf-8'))
        else:
            self.transport.loseConnection() #如果没有数据发送就关闭连接
    def dataReceived(self, data: bytes): #接收服务端的数据
        print(data.decode('utf-8'))
        self.send() #进行下一次数据发送
        return super().dataReceived(data)
    
class DefaultClientfactory(twisted.internet.protocol.ClientFactory):
    protocol = Client
    #如果连接断开 就停止reactor的循环
    clientConnectLost = clientCOnnectionFailed = lambda self, connector,reason : twisted.internet.reactor.stop()

def main():
    twisted.internet.reactor.connectTCP(SERVER_HOST,SERVER_PORT,DefaultClientfactory()) #服务监听
    twisted.internet.reactor.run() #启动reactor循环

if __name__ == '__main__':
    main()
</code></pre>
<p>整个框架还是处于一个模糊状态，但是对twisted的事件轮询机制还是有了一点清楚的认知。<br>
我的理解:</p>
<blockquote>
<p>将数据的处理和数据的接收发送、服务器的连接这两个部分剥离开。在reactor中如果接收到一个信息，那么就会调用到twisted循环中的某个处理程序，然后处理完成之后将数据返回给reactor进行发送，然后twisted事件就会继续循环。相当于将一个socket进程中的accept()阻塞和实际的处理剥离开，让处理程序不受到阻塞程序的影响，因此可以在一个进程中高效的处理多个客户端的连接，节省了服务器的资源。<br>
（有点像两个圈，reactor一个圈，twisted一个圈，当遇到数据需要处理的时候两个圈就会连一条线，处理完之后就把线擦去）</p>
</blockquote>
<h1 id="-7">=&gt;</h1>
<p>暂时先到这里，后面还有twisted的UDP客户端开发以及deferred的概念。 -- 2023-06-26</p>
<p>deferred</p>
]]></content>
    </entry>
</feed>